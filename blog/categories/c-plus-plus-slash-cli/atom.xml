<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: c++/cli | {love to code}]]></title>
  <link href="http://navaneeth.github.io/blog/categories/c-plus-plus-slash-cli/atom.xml" rel="self"/>
  <link href="http://navaneeth.github.io/"/>
  <updated>2014-06-16T19:34:48+05:30</updated>
  <id>http://navaneeth.github.io/</id>
  <author>
    <name><![CDATA[nkn]]></name>
    <email><![CDATA[navaneethkn@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Working with native code easily in C# with the help of C++/CLI]]></title>
    <link href="http://navaneeth.github.io/blog/2013/02/17/working-with-native-code-in-csharp-easily-with-cplusplus-cli/"/>
    <updated>2013-02-17T12:18:00+05:30</updated>
    <id>http://navaneeth.github.io/blog/2013/02/17/working-with-native-code-in-csharp-easily-with-cplusplus-cli</id>
    <content type="html"><![CDATA[<p>.NET comes with pretty good interoperability options which would enable unmanaged code to be used from a managed environment. In C#, to call a function which is available in a DLL, <code>PInvoke</code> (Platform invocation service) can be used. Here is what MSDN says.</p>

<blockquote><p>Platform Invocation Services (PInvoke) allows managed code to call unmanaged functions that are implemented in a DLL.</p></blockquote>

<p>This is very helpful when you need to call some system functions from your C# application. Now let us assume that you have lot of code which is written in C or C++. You are writing a brand new application in C# which internally uses the C/C++ code available. Since C/C++ code is categorised as unmanaged code, you can&rsquo;t directly use them in C#. At C# side, wrapper classes and functions has to be written to interop properly with the native code. As I said earlier, if you just need to use a single function, it is easy to do directly from C# using <code>PInvoke</code>. But when you need almost all the functionalities/API to be available as a managed object, <code>PInvoke</code> would be a pain to use. Let us take an example from <a href="http://msdn.microsoft.com/en-us/library/aa288468%28v=vs.71%29.aspx">MSDN</a></p>

<p><code>c
typedef struct tagLOGFONT
{
   LONG lfHeight;
   LONG lfWidth;
   LONG lfEscapement;
   LONG lfOrientation;
   LONG lfWeight;
   BYTE lfItalic;
   BYTE lfUnderline;
   BYTE lfStrikeOut;
   BYTE lfCharSet;
   BYTE lfOutPrecision;
   BYTE lfClipPrecision;
   BYTE lfQuality;
   BYTE lfPitchAndFamily;
   TCHAR lfFaceName[LF_FACESIZE];
} LOGFONT;
</code></p>

<p>In C#, this can be represented as</p>

<p>```csharp
// logfont.cs
// compile with: /target:module
using System;
using System.Runtime.InteropServices;</p>

<p>[StructLayout(LayoutKind.Sequential)]
public class LOGFONT
{</p>

<pre><code>public const int LF_FACESIZE = 32;
public int lfHeight; 
public int lfWidth; 
public int lfEscapement; 
public int lfOrientation; 
public int lfWeight; 
public byte lfItalic; 
public byte lfUnderline; 
public byte lfStrikeOut; 
public byte lfCharSet; 
public byte lfOutPrecision; 
public byte lfClipPrecision; 
public byte lfQuality; 
public byte lfPitchAndFamily;

[MarshalAs(UnmanagedType.ByValTStr, SizeConst=LF_FACESIZE)]
public string lfFaceName; 
</code></pre>

<p>}
```</p>

<p>Look at the C# example. It is not as clean as the structure definition at the C side. It contains attributes which specify the structure alignment, then marshaling etc. When the structure contains references to other structures, things gets complicated.</p>

<p>For C or C++ programmers, it is always convenient to declare the struct as they normally do. That&rsquo;s the beauty of <code>C++/CLI</code> which allows you to combine managed and unmanaged code together and makes interoperability very straightforward.</p>

<p>In this post, we will take <code>SQLite</code> as an example and write a managed class which can be consumed from C#. We will wrap SQLite code using <code>C++/CLI</code> and consume from C#. SQLite has a huge API and we won&rsquo;t be covering all of them. We will cover APIs which will allow to open a DB connection and execute a simple query.</p>

<p>Note: SQLite is chosen as an example. The correct way to wrap SQLite is adhering to ADO.NET standards and providing a API by extending IDBConnection. But for this post, we will ignore this and provide a custom simple API.</p>

<h2>SQLite API</h2>

<p>We will wrap the following functions</p>

<p><code>c
int sqlite3_open(const char *filename, sqlite3 **ppDb);
int sqlite3_exec(
  sqlite3*,                                  /* An open database */
  const char *sql,                           /* SQL to be evaluated */
  int (*callback)(void*,int,char**,char**),  /* Callback function */
  void *,                                    /* 1st argument to callback */
  char **errmsg                              /* Error msg written here */
);
</code></p>

<p>Our managed API will look like,</p>

<p><code>csharp
SQLite db = new SQLite(filePath);
db.Execute(sql, callback);
</code></p>

<p><code>callback</code> can be assigned to a function which takes 2 parameters of type <code>List&lt;String&gt;</code>. It will contain column names and values respectively.</p>

<h2>Wrapper class in C++/CLI</h2>

<p>We will have a Visual studio solution with 3 projects.</p>

<ul>
<li>Static library which contains SQLite source code. This will be compiled as C and produces a static library.</li>
<li>C++/CLI library project which adds the first project as a reference.</li>
<li>A C# console application for testing. This project will have a reference to the assembly generated by C++/CLI project.</li>
</ul>


<p><img src="/images/posts/20130217/solution_explorer.png" alt="Solution explorer" /></p>

<p>In C++/CLI, we start off by creating the following class.</p>

<p>```c++
// SQLiteWrapper.h</p>

<h1>pragma once</h1>

<h1>include &ldquo;sqlite3.h&rdquo;</h1>

<p>using namespace System;
using namespace System::Collections::Generic;</p>

<p>namespace SQLiteWrapper {</p>

<pre><code>// Main class that wraps the native API
public ref class SQLite : IDisposable
{
public:
    SQLite(String^ filePath);
    void Execute(String^ sql, Action&lt;List&lt;String^&gt;^, List&lt;String^&gt;^&gt;^ callback);
    ~SQLite();

private:
    sqlite3* db;
};

public ref class SQLiteError : Exception
{
public:
    SQLiteError(String^ errorMessage);
};

private ref class SQLiteDataCarrier
{
public:
    SQLiteDataCarrier(List&lt;String^&gt;^ columnNames, List&lt;String^&gt;^ columnValues)
    {
        this-&gt;columnNames = columnNames;
        this-&gt;columnValues = columnValues;
    }

    property List&lt;String^&gt;^ ColumnNames
    {
        List&lt;String^&gt;^ get()
        {
            return columnNames;
        }
    }

    property List&lt;String^&gt;^ ColumnValues
    {
        List&lt;String^&gt;^ get()
        {
            return columnValues;
        }
    }

private:
    List&lt;String^&gt;^ columnNames;
    List&lt;String^&gt;^ columnValues;
};
</code></pre>

<p>}
```</p>

<p>This class holds an instance to <code>sqlite3</code> structure which is the core of SQLite library. Even though the class is a managed class, C++/CLI allows you to hold a pointer which points to <code>sqlite3</code>.</p>

<p>Our constructor can be implemented like,</p>

<p>```c++
// Constructor for managed class SQLite
SQLite::SQLite(String^ filePath)
{</p>

<pre><code>IntPtr p = Marshal::StringToHGlobalAnsi(filePath);
const char* _filePath = static_cast&lt;const char*&gt;(p.ToPointer());

try
{
    sqlite3* d;
    int status = sqlite3_open(_filePath, &amp;d);
    if (status)
        throw gcnew SQLiteError("Unable to open database");


    // Holding the DB pointer as a field
    // This is a pointer to native struct, but it can be stored in managed class!
    db = d;
}
finally
{
    Marshal::FreeHGlobal(p);

}
</code></pre>

<p>}
```</p>

<p>This code shows how well C++/CLI allows you to mix types from both managed and unmanaged world. It is beautiful!</p>

<p>All this constructor does is to initialize <code>sqlite3</code> instance and update the <code>db</code> pointer with correct reference.</p>

<p>Here is how <code>Execute()</code> method is implemented.</p>

<p>```c++
// Callback function called by SQLite.
// This function shows how native and managed objects can work together!
static int _callback(void *userData, int argc, char <strong>argv, char </strong>azColName)
{</p>

<pre><code>IntPtr pointer(userData);
GCHandle handle = GCHandle::FromIntPtr(pointer);
SQLiteDataCarrier^ carrier = (SQLiteDataCarrier^) handle.Target;

for(int i = 0; i &lt; argc; i++)
{
    const char* columnName = azColName[i];
    const char* columnValue = argv[i];

    carrier-&gt;ColumnNames-&gt;Add(gcnew String(columnName));
    carrier-&gt;ColumnValues-&gt;Add(gcnew String(columnValue));
}

return 0;
</code></pre>

<p>}</p>

<p>void SQLite::Execute(String^ sql, Action&lt;List&lt;String^>^, List&lt;String^>^>^ callback)
{</p>

<pre><code>IntPtr p = Marshal::StringToHGlobalAnsi(sql);
const char* _sql = static_cast&lt;const char*&gt;(p.ToPointer());

// Output will be stored in these lists
List&lt;String^&gt;^ columnNames = gcnew List&lt;String^&gt;();
List&lt;String^&gt;^ columnValues = gcnew List&lt;String^&gt;();

// A simple class to aggregate columnNames and columnValues so that it can be passed to SQLite and SQLite will give it back in the callback function
SQLiteDataCarrier^ carrier = gcnew SQLiteDataCarrier(columnNames, columnValues);

// Converting carrier to void*
GCHandle handle = GCHandle::Alloc(carrier);
IntPtr pointer = GCHandle::ToIntPtr(handle);

char *zErrMsg = 0;
int status = sqlite3_exec(db, _sql, _callback, pointer.ToPointer(), &amp;zErrMsg);
if (status != SQLITE_OK)
{
    String^ message = gcnew String(sqlite3_errmsg(db));
    throw gcnew SQLiteError(message);
}

callback-&gt;Invoke(columnNames, columnValues);

handle.Free();
Marshal::FreeHGlobal(p);
</code></pre>

<p>}
```</p>

<p>To add results into the list, we are passing both lists to the <code>sqlite3_exec()</code> function so that SQLite will pass that back to the <code>_callback</code> function. This is very powerful because we just passed a managed object into a native function call. Then in a native function, we obtained the managed instance and modified properties on it.</p>

<p>Once the querying is done, database has to be closed. We do that in the destructor.</p>

<p>```c++
// In C++/CLI destructor will be implemented using Dispose() pattern
SQLite::~SQLite()
{</p>

<pre><code>sqlite3_close(db);
</code></pre>

<p>}
```</p>

<h2>Using from C#</h2>

<p>Usage from C# now becomes pretty straightforward.</p>

<p>```csharp
namespace ConsoleApplication1
{</p>

<pre><code>class Program
{
    static void Main(string[] args)
    {
        SQLite db = new SQLite("C:\\Users\\navaneeth\\Desktop\\test\\example.db");
        string sql = "create table if not exists foos (name text);\n" +
            "insert into foos values ('sample1');" +
            "insert into foos values ('sample2');" +
            "select * from foos;";
        db.Execute(sql, (columnNames, columnValues) =&gt; {
            foreach (var name in columnNames)
            {
                Console.WriteLine(name);
            }
            foreach (var value in columnValues)
            {
                Console.WriteLine(value);
            }
        });
        db.Dispose();
        Console.Read();
    }
}
</code></pre>

<p>}
```</p>

<p>You can download the code <a href="https://dl.dropbox.com/u/52296034/blog/SQLiteWrapper.zip">here</a>. Happy programming!</p>
]]></content>
  </entry>
  
</feed>
