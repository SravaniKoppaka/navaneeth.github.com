<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: .net, | {love to code}]]></title>
  <link href="http://navaneeth.github.com/blog/categories/-net-/atom.xml" rel="self"/>
  <link href="http://navaneeth.github.com/"/>
  <updated>2013-07-29T08:40:33+05:30</updated>
  <id>http://navaneeth.github.com/</id>
  <author>
    <name><![CDATA[nkn]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Disabling a custom control from Visual Studio’s toolbox]]></title>
    <link href="http://navaneeth.github.com/blog/2009/09/15/disabling-a-custom-control-from-visual-studios-toolbox/"/>
    <updated>2009-09-15T23:52:00+05:30</updated>
    <id>http://navaneeth.github.com/blog/2009/09/15/disabling-a-custom-control-from-visual-studios-toolbox</id>
    <content type="html"><![CDATA[<p>When a custom control is created, Visual Studio will show it in the toolbox for dragging and dropping. This can be annoying when you create a composite control which is a combination of several other custom controls where VS will display all custom controls in the toolbox. <code>System.ComponentModel.ToolBoxItemAttribute</code> can be used with the controls that you want to hide from toolbox. Apply this attribute to all the controls that you want to hide from toolbox.</p>

<p>Sample code</p>

<p><code>csharp
[System.ComponentModel.ToolboxItem(false)]
public class MyCustomControl : Label
{
}
</code></p>

<p><code>MyCustomControl</code> will not be displayed on the toolbox.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Circular linked list – An implementation using C#]]></title>
    <link href="http://navaneeth.github.com/blog/2009/08/18/circular-linked-list-an-implementation-using-c-number/"/>
    <updated>2009-08-18T22:12:00+05:30</updated>
    <id>http://navaneeth.github.com/blog/2009/08/18/circular-linked-list-an-implementation-using-c-number</id>
    <content type="html"><![CDATA[<p>In this post, I will explain about creating a circular doubly linked list using C#. .NET framework provides a doubly linked list implementation in System.Collections.Generic.LinkedList<T> class . But this class is not providing the behavior of a circular linked list and it is very tough to extend for supporting circular linked list requirements.</p>

<p>In a normal doubly linked list, each node will have a link to its previous and next nodes. In a circular doubly linked list, tail node’s next node will be head and head node’s previous node will be tail. Here is an image taken from wikipedia which visualizes circular linked list.</p>

<p><img src="images/posts/circular_linked_list.png" title="Circular linked list" alt="Alt text" /></p>

<p> Here is our requirements for the circular linked list</p>

<ul>
<li>Adding items to the list should be O(1).</li>
<li>Provide similar interface like the standard LinkedList<T> class.</li>
<li>Keep items in a type-safe way.</li>
<li>Avoid using collections like List or array internally for keeping items.</li>
<li>Should provide access to Head and Tail</li>
<li>Option to enumerate all items</li>
<li>Reverse enumeration</li>
<li>Access items with an index.</li>
<li>Maintain collection semantics.</li>
</ul>


<p>Here is the class diagram.</p>

<p><img src="images/posts/classdiagram1.png" title="Class diagram" alt="Alt text" /></p>

<h2>Node&lt;T&gt; class</h2>

<blockquote><p>Every problem can be solved by adding another layer of indirection.</p></blockquote>

<p>Node class is a layer of indirection added to hold the linked list value. It manages the next and previous items and provides an option to get the current value. This class is immutable. Here is Node class looks like,</p>

<p>```csharp
/// <summary>
/// Represents a node
/// </summary>
/// <typeparam name="T"></typeparam>
[DebuggerDisplay("Value = {Value}")]
public sealed class Node<T>
{</p>

<pre><code>/// &lt;summary&gt;
/// Gets the Value
/// &lt;/summary&gt;
public T Value { get; private set; }

/// &lt;summary&gt;
/// Gets next node
/// &lt;/summary&gt;
public Node&lt;T&gt; Next { get; internal set; }

/// &lt;summary&gt;
/// Gets previous node
/// &lt;/summary&gt;
public Node&lt;T&gt; Previous { get; internal set; }

/// &lt;summary&gt;
/// Initializes a new &lt;see cref="Node"/&gt; instance
/// &lt;/summary&gt;
/// &lt;param name="item"&gt;Value to be assigned&lt;/param&gt;
internal Node(T item)
{
    this.Value = item;
}
</code></pre>

<p>}
```</p>

<h2>CircularLinkedList&lt;T&gt; class</h2>

<p>Keeping the requirements in mind, let us start writing the generic CircularLinkedList<T>. Some linked list implementations maintains only a link to the head node and when adding a new item to the list, each node in the list has to be traveled till tail node is found and this gives O(n) complexity for the algorithm.</p>

<p>Maintaining link to head and tail helps us to do insertions with a O(1) complexity. In such cases, list traversal is not required. All we need is to change the pointer in the tail node. Head and tail node are member variables of CircularLinkedList class.</p>

<p>```csharp
public sealed class CircularLinkedList<T>
{</p>

<pre><code>[DebuggerBrowsable(DebuggerBrowsableState.Never)]
Node head = null;

[DebuggerBrowsable(DebuggerBrowsableState.Never)]
Node tail = null;
</code></pre>

<p>}
```</p>

<p>To add an item to the last, we need to create a new node from the supplied item. Set the new node’s next pointer pointing to the list’s head and previous pointing to the tail. Finally, tail will be replaced with the new node. Here is the <code>AddLast()</code> method implementation.</p>

<p>```csharp
public void AddLast(T item)
{</p>

<pre><code>// if head is null, then this will be the first item
if (head == null)
    this.AddFirstItem(item);
else
{
    Node&lt;T&gt; newNode = new Node&lt;T&gt;(item);
    tail.Next = newNode;
    newNode.Next = head;
    newNode.Previous = tail;
    tail = newNode;
    head.Previous = tail;
}
++count;
</code></pre>

<p>}</p>

<p>void AddFirstItem(T item)
{</p>

<pre><code>head = new Node&lt;T&gt;(item);
tail = head;
head.Next = tail;
head.Previous = tail;
</code></pre>

<p>}
```</p>

<p>We can easily add another method that will add item to the first position in the list. Implementation looks similar like <code>AddLast()</code>. Unlike <code>AddLast()</code>, head node’s previous pointer will be re-pointed to the new node. The new node’s previous and next pointer will be pointed to tail and head respectively. Finally head will be replaced with the new node.</p>

<p>```csharp
public void AddFirst(T item)
{</p>

<pre><code>if (head == null)
    this.AddFirstItem(item);
else
{
    Node&lt;T&gt; newNode = new Node&lt;T&gt;(item);
    head.Previous = newNode;
    newNode.Previous = tail;
    newNode.Next = head;
    tail.Next = newNode;
    head = newNode;
}
++count;
</code></pre>

<p>}
```</p>

<p>Finding an item from the list will have a <code>O(n)</code> complexity as it needs to traverse through all items in the list until we get a matching item. Here is a recursive implementation.</p>

<p>```csharp
public Node<T> Find(T item)
{</p>

<pre><code>Node&lt;T&gt; node = FindNode(head, item);
return node;
</code></pre>

<p>}</p>

<p>Node<T> FindNode(Node<T> node, T valueToCompare)
{</p>

<pre><code>Node&lt;T&gt; result = null;
if (comparer.Equals(node.Value, valueToCompare))
    result = node;
else if (result == null &amp;&amp; node.Next != head)
    result = FindNode(node.Next, valueToCompare);
return result;
</code></pre>

<p>}
```</p>

<p>Providing an iterator to iterate the items in the list will be useful. Since this is a circular linked list, a reverse iterator also makes sense. <code>yield</code> keyword makes iterator implementations almost trivial.</p>

<p>```csharp
public IEnumerator<T> GetEnumerator()
{</p>

<pre><code>Node&lt;T&gt; current = head;
if (current != null)
{
    do
    {
        yield return current.Value;
        current = current.Next;
    } while (current != head);
}
</code></pre>

<p>}</p>

<p>public IEnumerator<T> GetReverseEnumerator()
{</p>

<pre><code>Node&lt;T&gt; current = tail;
if (current != null)
{
    do
    {
        yield return current.Value;
        current = current.Previous;
    } while (current != tail);
}
</code></pre>

<p>}
```</p>

<p>Removing items from list is also just re-pointing the previous and next pointers of the node’s previous.</p>

<p>```csharp
public bool Remove(T item)
{</p>

<pre><code>// finding the first occurance of this item
Node&lt;T&gt; nodeToRemove = this.Find(item);
if (nodeToRemove != null)
    return this.RemoveNode(nodeToRemove);
return false;
</code></pre>

<p>}</p>

<p>bool RemoveNode(Node<T> nodeToRemove)
{</p>

<pre><code>Node&lt;T&gt; previous = nodeToRemove.Previous;
previous.Next = nodeToRemove.Next;
nodeToRemove.Next.Previous = nodeToRemove.Previous;

// if this is head, we need to update the head reference
if (head == nodeToRemove)
    head = nodeToRemove.Next;
else if (tail == nodeToRemove)
    tail = tail.Previous;

--count;
return true;
</code></pre>

<p>}
```</p>

<p>Finally, an indexer is provided so that list items can be accessed using an index. Like <code>Find()</code> method, this also has a <code>O(n)</code> complexity.</p>

<p>```csharp
public Node<T> this[int index]
{</p>

<pre><code>get
{
    if (index &gt;= count || index &lt; 0)
        throw new ArgumentOutOfRangeException("index");
    else
    {
        Node&lt;T&gt; node = this.head;
        for (int i = 0; i &lt; index; i++)
            node = node.Next;
        return node;
    }
}
</code></pre>

<p>}
```</p>

<p>To get a collection semantics and maintain similar interface like the standard LinkedList, we implement <code>ICollection&lt;T&gt;</code> and <code>IEnumerable&lt;T&gt;</code> interfaces.</p>

<p>```csharp
public sealed class CircularLinkedList<T> : ICollection<T>, IEnumerable<T>
{</p>

<pre><code>// code
</code></pre>

<p>}
```</p>

<h2>Test harness</h2>

<p>Following code shows how this class can be used,</p>

<p>```csharp
static void Main(string[] args)
{</p>

<pre><code>CircularLinkedList&lt;int&gt; list = new CircularLinkedList&lt;int&gt;();
list.AddLast(1);
list.AddLast(2);
list.AddLast(3);
Console.WriteLine("List count = {0}", list.Count);
Console.WriteLine("Head  = {0}", list.Head.Value);
Console.WriteLine("Tail  = {0}", list.Tail.Value);
Console.WriteLine("Head's Previous  = {0}", list.Head.Previous.Value);
Console.WriteLine("Tail's Next  = {0}", list.Tail.Next.Value);
Console.WriteLine("************List Items***********");
foreach (int i in list)
    Console.WriteLine(i);

Console.WriteLine("************List Items in reverse***********");
for (IEnumerator&lt;int&gt; r = list.GetReverseEnumerator(); r.MoveNext(); )
    Console.WriteLine(r.Current);

Console.WriteLine("************Adding a new item at first***********");
list.AddFirst(0);
foreach (int i in list)
    Console.WriteLine(i);

Console.WriteLine("************Adding item before***********");
list.AddBefore(2,11);
foreach (int i in list)
    Console.WriteLine(i);

Console.WriteLine("************Adding item after***********");
list.AddAfter(3, 4);
foreach (int i in list)
    Console.WriteLine(i);

Console.ReadKey();
</code></pre>

<p>}
```</p>

<h2>Possible expansions</h2>

<p>There are good and complex features that can be added to this list. Here are few that will be useful,</p>

<ul>
<li>Remove duplicate nodes.</li>
<li>Move nodes around.</li>
<li>Sorting.</li>
</ul>


<p>Probably we will see these features in another post.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ADO.NET best practices – Reading data from data reader]]></title>
    <link href="http://navaneeth.github.com/blog/2009/07/11/ado-dot-net-best-practices-reading-data-from-data-reader/"/>
    <updated>2009-07-11T23:38:00+05:30</updated>
    <id>http://navaneeth.github.com/blog/2009/07/11/ado-dot-net-best-practices-reading-data-from-data-reader</id>
    <content type="html"><![CDATA[<p>I have seen many people using DataReader incorrectly. In this post, I will try to explain some good practices that can be followed when reading from a data reader. Consider the following problematic code,</p>

<p>```csharp
SqlDataReader reader = /<em> ... </em>/;
while (reader.Read())
{</p>

<pre><code>string userName = reader["user_name"].ToString();
int age = int.Parse( reader["age"].ToString() );
/* ... */
</code></pre>

<p>}
reader.Close();
```</p>

<p>How many problems can you figure out from the above code? There are many problems with this code,</p>

<ul>
<li>The columns “user_name” and “age” may or may not exist. If the column does not exist in the reader, it will throw error.</li>
<li>You may be calling <code>ToString()</code> on an object which may be pointing to <code>NULL</code>. This will lead to a null reference exception.</li>
<li><code>SqlDataReader</code> implements <code>IDisposable</code> and user code has to call <code>Dispose()</code> each time to release the resources deterministically. This is not happening here.</li>
<li><code>reader["age"]</code> may contain values that are not compatible with integer. In such case, <code>int.Parse()</code> will throw a <code>FormatException</code>.</li>
</ul>


<p>Following sections will show a safe method to read data from DataReader.</p>

<h2>Understanding ordinals</h2>

<p>Ordinal is the index of a column in the reader. <code>GetOrdinal()</code> method will give you the ordinal for the column name supplied. So the first step in reading data from reader should be to find the ordinal of the columns which we want to read. Before getting the ordinal values, you have to ensure that the reader can read. SqlDataReader provides a HasRows property which can be useful here. Here is how you read the ordinals</p>

<p>```csharp
SqlDataReader reader = /<em> ... </em>/;
int userNameOrdinal;
int ageOrdinal;
if (reader.HasRows)
{</p>

<pre><code> try
 {
       userNameOrdinal = reader.GetOrdinal("user_name");
 }
 catch (IndexOutOfRangeException)
 {
       throw new YourCustomException("Expected column 'user_name' not found");
 }
 try
 {
       ageOrdinal = reader.GetOrdinal("age");
 }
 catch (IndexOutOfRangeException)
 {
       throw new YourCustomException("Expected column 'age' not found");
 }
</code></pre>

<p>}
```</p>

<p>If you have support to “Extension methods”, this code can be simplified further.</p>

<p>```csharp
public static class SqlDataReaderExtensions
{</p>

<pre><code>public static int GetOrdinalOrThrow(this SqlDataReader reader, string columnName)
{
    try
    {
        return reader.GetOrdinal(columnName);
    }
    catch (IndexOutOfRangeException)
    {
        throw new YourCustomException(string.Format("Expected column '{0}' not found",columnName));
    }
}
</code></pre>

<p>}</p>

<p>SqlDataReader reader = /<em> ... </em>/;
int userNameOrdinal;
int ageOrdinal;
if (reader.HasRows)
{</p>

<pre><code>  userNameOrdinal = reader.GetOrdinalOrThrow("user_name");
  ageOrdinal = reader.GetOrdinalOrThrow("age");
</code></pre>

<p>}
```</p>

<p>This makes the code more clean. However, I really wish to see a <code>TryGetOrdinal()</code> method on <code>IDataReader</code> so that we can save the cost of exception handling.</p>

<p>GetOrdinal() method first does a case-sensitive lookup for the column name. If it fails, case-insensitive search is performed. Thus, using the column name in correct case with GetOrdinal() will be more efficient.</p>

<h2>Respecting type safety</h2>

<p>C# is a strongly typed language and each programmer should take full advantage of this. Reading data like, <code>reader["user_name"]</code> is not a type safe way as it returns a object. Data reader provides methods to read data in a type safe way.</p>

<p>Here is what MSDN says about it</p>

<blockquote><pre><code>When accessing column data use the typed accessors like GetString, GetInt32, and so on. This saves you the processing required to cast the Object returned from GetValue as a particular type. 
</code></pre></blockquote>

<p>Now let us follow the above suggestion and rewrite our code like,</p>

<p>```csharp
while (reader.Read())
{
   string userName = reader.GetString(userNameOrdinal);
   int age = -1;
   try
   {</p>

<pre><code>     age = reader.GetInt32(ageOrdinal);
</code></pre>

<p>   }
   catch (InvalidCastException)
   {</p>

<pre><code>     throw new YourCustomException("Unable to read age. Expecting integer value");
</code></pre>

<p>   }
   /<em> ... </em>/
}
```</p>

<h2>Releasing resources</h2>

<p>If any type implements IDisposable, it is like saying “I have something to release explicitly rather than garbage collector to release it“. So it is programmers duty to ensure the calls to Dispose() when using disposable types. C# has “using” statement (stack semantics can be used in C++/CLI) which will ensure calls to Dispose(). Since DataReader is a disposable object, we can write like</p>

<p>```csharp
using(SqlDataReader reader = command.ExecuteReader())
{</p>

<pre><code>  while (reader.Read())
  {
      string userName = reader.GetString(userNameOrdinal);
      int age = -1;
      try
      {
          age = reader.GetInt32(ageOrdinal);
      }
      catch (InvalidCastException)
      {
          throw new YourCustomException("Unable to read age. Expecting integer value");
      }
      /* ... */
  }
</code></pre>

<p>}
```</p>

<p>This ensures that the reader is disposed properly even in exceptional situations.</p>

<h2>Putting everything together</h2>

<p>If you put everything together, code will be like</p>

<p>```csharp
public static class SqlDataReaderExtensions
{</p>

<pre><code>public static int GetOrdinalOrThrow(this SqlDataReader reader, string columnName)
{
    try
    {
        return reader.GetOrdinal(columnName);
    }
    catch (IndexOutOfRangeException)
    {
        throw new YourCustomException(string.Format("Expected column '{0}' not found",columnName));
    }
}
</code></pre>

<p>}</p>

<p>int userNameOrdinal = -1;
int ageOrdinal = -1;
if (reader.HasRows)
{</p>

<pre><code>userNameOrdinal = reader.GetOrdinalOrThrow("user_name");
ageOrdinal = reader.GetOrdinalOrThrow("age");
</code></pre>

<p>}
using (SqlDataReader reader = GetReader())
{</p>

<pre><code>while (reader.Read())
{
    string userName = reader.GetString(userNameOrdinal);
    int age = -1;
    try
    {
        age = reader.GetInt32(ageOrdinal);
    }
    catch (InvalidCastException)
    {
        throw new YourCustomException("Unable to read age. Expecting integer value");
    }
    /* ... */
}
</code></pre>

<p>}
```</p>

<p>We have got clean code now. It handles the exceptions and throws informative exceptions to the caller rather than throwing Boneheaded exceptions, we have avoided explicit casting and DataReader is disposed properly.</p>

<p>These are applicable for all types which implements <code>IDataReader</code>. <code>SqlDataReader</code> is used in this post just for explanation.</p>

<p>Happy programming!</p>
]]></content>
  </entry>
  
</feed>
